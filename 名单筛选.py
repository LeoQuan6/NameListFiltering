"""
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠻⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⣀⡾⠀⠀⣿
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡶⠟⠛⠉⠉⠀⠀⠀⠀⠀⠀⠉⠉⠛⠻⠿⣤⣀⣠⡴⠋
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⠂⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠉⠀⠀⠀⠀⠀⠀⡴⠁⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠋⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⠀⠀⡾⠀⠀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⠀⠀⠈⢷⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⠀⠀⠀⠀⣠⠃⠀⠀⠀⠀⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⠀⠀⠀⠙⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⣀⣿⢠⠀⠀⠀⠀⠀⠀⠀⠀⣶⠀⣧⠀⠀⠀⠀⠀⠀⠀⠈⣆
⠀⠀⠀⠀⠀⠀⠀⠀⣼⠁⠀⣰⠀⠀⠀⠀⣾⢸⣿⣀⣤⣶⡛⠁⣿⠘⡄⠀⠀⠀⠀⢀⠀⠀⣿⠀⢻⠀⠀⠀⠀⠀⠀⠀⠀⠸
⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⡟⠀⠀⠀⠀⣿⡈⡏⠀⠀⠀⠀⠙⡜⡄⢿⠀⠀⠀⠀⣾⣧⣾⢸⠀⢸⠀⠀⡇⠀⠀⠀⠀⠀⠀⡇
⠀⠀⠀⠀⠀⠀⠀⢀⡇⠀⠀⣇⠀⠀⠀⠀⣷⣿⣿⣶⣦⣀⠀⠀⠀⠹⡘⣿⡀⠀⠀⢹⣿⠃⢸⠀⣿⠀⢠⣿⠀⠀⠀⠀⠀⣄⣧
⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⣿⠀⠀⠀⠀⢿⠉⠉⠉⠻⣿⣷⡀⠀⠀⠈⠁⠙⢦⣀⣸⠋⠈⣸⣼⢻⠀⣾⡿⠀⠀⠀⠀⢸⢸⣿
⠀⠀⠀⠀⠀⠀⠀⣿⠀⣿⠀⠸⡄⣤⠀⠀⠀⣧⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⣿⣿⠇⠀⠀⠀⠀⣾⢸⣿
⠀⠀⠀⠀⠀⠀⢰⡇⠀⣿⠀⠀⠙⠿⣿⠛⠒⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣦⡀⡿⠀⠀⠀⠀⠀⣿⣿⣿
⠀⠀⠀⠀⠀⠀⣿⠀⣴⠋⠙⣦⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⣼⠉⠙⠳⠦⣤⡀⠀⠀⠀⠀⠀⠀⠈⠻⡿⠀⠀⠀⠀⠀⠀⣿⣿⣿
⠀⠀⠀⠀⠀⠀⣿⢤⠇⣀⡀⣼⠀⠀⠀⢹⠀⠀⠀⠀⠀⢸⠁⠀⠀⠀⠀⢰⠁⠀⠀⠀⠀⠀⠀⣠⠟⠀⠀⠀⠀⠀⠀⢠⣯⣿⣿
⠀⠀⠀⠀⣠⠋⣠⠟⠁⠀⠈⠛⣄⠀⠀⠀⣇⠀⠀⠀⠀⢹⠀⠀⠀⠀⢀⠟⠀⠀⠀⠀⠀⠀⢾⣁⠀⠀⠀⠀⢀⣾⣤⡏⠉⠉⣿
⠀⠀⢀⣞⠤⣴⠁⠀⠀⠀⠀⠀⠀⣧⠀⠀⢿⠉⠳⣤⡀⠀⠁⠀⠠⠶⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠧⣴⣾⣿⣿⠟⡇⠀⠀⢸
⣠⠚⠁⢀⠏⣿⠀⠀⠀⠀⠀⠀⠀⠸⡀⠀⠈⡏⠛⠶⣤⡉⠛⠶⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⣀⡴⣿⣿⠟⠁⠀⠀⡇⠀⠀⢸
⠀⠀⠀⢸⠀⠘⡄⠀⠀⠀⠀⠀⢹⠀⡿⡄⠀⣿⠀⠀⠀⠀⠙⠲⣤⡀⠙⢦⠉⠉⠉⠉⠉⠉⠁⠀⠀⣿⠀⠀⠀⠀⠀⡇⠀⠀⢸
⠀⠀⠀⠘⡄⠀⣿⠀⠀⠀⠀⠀⣸⠛⡄⢻⠀⠸⡀⠀⠀⠀⠀⠀⠀⠈⠛⢦⡉⢦⡀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⢰⠇⠀⠀⢸
⠀⠀⠀⠀⢿⠀⠈⠙⢦⣄⣠⠴⠃⢠⠃⠀⡇⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢾⣦⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⣼⠀⠀⠀⠀⡇
⠀⠀⠀⠀⠀⠙⢤⠀⠀⠀⠀⠀⡴⠋⠀⠀⡇⠀⢿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⡿⠀⠀⠀⠀⡿⠀⠀⠀⠀⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⠀⠘⣿⣿⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⠀⠀⡇⠀⠀⠀⢰⠁⠀⠀⠀⠀⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⠀⠀⠀⣿⣿⣿⣿⣷⣶⣶⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⠀⠀⡿⠀⠀⠀⠀⠀⣷
"""

import pandas as pd
import os
import time
import re


# 获取桌面路径
def get_desktop_path():
    """
    获取用户桌面路径
    """
    if os.name == 'nt':  # Windows
        return os.path.join(os.environ['USERPROFILE'], 'Desktop')
    else:  # macOS or Linux
        return os.path.join(os.environ['HOME'], 'Desktop')


# 读取Excel文件的函数
def read_excel(file_path):
    """
    读取Excel文件，并返回DataFrame
    """
    try:
        df = pd.read_excel(file_path)
        return df
    except Exception as e:
        print(f"读取文件失败: {e}")
        return None


# 根据姓名筛选数据并生成新的表格
def filter_data_by_names(df, names, columns):
    """
    根据姓名筛选数据并生成新的表格
    """
    # 根据姓名筛选数据
    filtered_df = df[df['姓名'].isin(names)][columns]

    # 强制将学号列转换为字符串，避免科学计数法
    for col in ['学号', '联系方式']:
        if col in filtered_df.columns:
            filtered_df[col] = filtered_df[col].astype(float).astype('Int64')

    return filtered_df


# 生成新的Excel文件，使用xlsxwriter设置格式
def save_to_excel(data, output_file):
    """
    保存筛选后的数据到新的Excel文件，并应用一些格式
    """
    desktop_path = get_desktop_path()
    if not output_file.endswith('.xlsx'):
        output_file += '.xlsx'
    output_file_path = os.path.join(desktop_path, output_file)

    # 使用xlsxwriter引擎保存数据
    writer = pd.ExcelWriter(output_file_path, engine = 'xlsxwriter')
    data.to_excel(writer, sheet_name = 'Sheet1', index = False)

    # 获取工作簿和工作表对象
    workbook = writer.book
    worksheet = writer.sheets['Sheet1']

    # 创建格式对象：字体为宋体，字号为11，水平居中和垂直居中
    cell_format = workbook.add_format({'font_name': '宋体', 'font_size': 11, 'align': 'center', 'valign': 'vcenter'})

    # 设置列宽和应用格式
    for idx, col in enumerate(data.columns):
        # 计算列中每个单元格的显示宽度
        max_length = max(
            data[col].astype(str).apply(lambda x: calculate_display_length(x)).max(),
            calculate_display_length(col)
            ) + 2

        # 应用列宽和单元格格式
        worksheet.set_column(idx, idx, max_length, cell_format)

    # 设置行高并应用单元格格式
    for row in range(len(data) + 1):  # 包括标题行
        worksheet.set_row(row, None, cell_format)

    # 保存Excel文件
    writer.close()
    print(f"带有格式的Excel文件已保存在桌面 {output_file_path}")


# 计算字符串的显示长度（考虑汉字和英文字母的差异）
def calculate_display_length(value):
    """
    计算字符串的显示长度，汉字长度计为2，其他字符长度计为1
    """
    length = 0
    for char in str(value):
        if re.match(r'[\u4e00-\u9fff]', char):  # 判断是否为汉字
            length += 2
        else:
            length += 1
    return length


# 获取有效的姓名输入
def get_valid_names(df):
    """
    获取有效的姓名输入
    """
    available_names = df['姓名'].tolist()

    while True:
        names_input = input("请输入要查询的姓名，多个姓名用空格分隔：")
        names = [name.strip() for name in names_input.split(' ')]
        not_found_names = [name for name in names if name not in available_names]

        if not_found_names:
            print(f"\r\n未找到以下姓名：{', '.join(not_found_names)}")
            print("请重新输入有效的姓名。\r\n")
        else:
            return names


# 获取有效的列名输入，新增了默认报名模板的判断
def get_valid_columns(df):
    """
    获取有效的列名输入
    """
    default_columns = ["姓名", "性别", "学院", "专业", "学号", "西/南区", "联系方式"]

    columns_input = input("是否使用默认报名模版？\r\n如果是，请直接按下回车；如果不是，请输入列名：")

    if not columns_input.strip():  # 如果用户直接按下回车，则使用默认模板
        columns = default_columns
        print(f"\r\n使用默认列名：{', '.join(columns)}")
    else:
        while True:
            columns = [column.strip() for column in columns_input.split()]
            # 检查用户输入的列名是否在原表格中
            invalid_columns = [col for col in columns if col not in df.columns]
            if invalid_columns:
                print(f"\r\n以下列名在原表格中不存在：{', '.join(invalid_columns)}")
                columns_input = input("请重新输入有效的列名：\r\n")
            else:
                break  # 所有列名都有效，退出循环
    return columns


# 示例调用函数
def main():
    # 默认文件名
    default_file_name = "2024内外交流部名单.xlsx"

    # 检查当前目录是否存在该文件
    if os.path.exists(default_file_name):
        file_path = default_file_name
        print(f"文件 '{default_file_name}' 已找到，正在读取...")
    else:
        file_path = input("请输入Excel文件路径：").strip().strip('"').strip("'")

    # 读取原始Excel文件
    df = read_excel(file_path)

    if df is None:
        print("文件读取失败, 请检查文件路径是否正确\r\n程序即将重启...\r\n")
        print("-------------------------------------------------------\r\n\r\n\r\n")
        time.sleep(2)
        main()  # 如果读取失败，则重启程序

    # 输出表格的列标题
    print("原始Excel表格的列标题：", df.columns.tolist())

    # 获取有效姓名和列名
    names = get_valid_names(df)
    columns = get_valid_columns(df)

    # 根据姓名和列名筛选数据
    filtered_data = filter_data_by_names(df, names, columns)

    # 输出结果
    if not filtered_data.empty:
        print("筛选后的数据：")
        print(filtered_data)

        # 保存结果到新的Excel文件
        output_file = input("请输入输出的Excel文件名：")
        save_to_excel(filtered_data, output_file)
        print("程序已结束, 窗口将在五秒后关闭...")
        time.sleep(5)

    else:
        print("意想不到的bug ")
        time.sleep(30)


# 执行主程序
if __name__ == "__main__":
    main()
